#!/bin/bash
#
# files2xml - Convert files to XML with metadata and content
#
set -eEuo pipefail

# Constants
declare -r XML_VERSION='1.0'
declare -r XML_ENCODING='UTF-8'
declare -i MAX_FILE_SIZE=$((1024*1024*1024))
declare -a IGNORE=('*.mp*' '~*' '*~' '*.bak' '*.log' '*.old' '*LI*')
declare -i VERBOSE=0

# Escape XML special characters
# Args: $1 - String to escape
xml_escape() {
  local s="${1:-}"
  s="${s//&/&amp;}"
  s="${s//</&lt;}"
  s="${s//>/&gt;}"
  s="${s//\"/&quot;}"
  s="${s//\'/&apos;}"
  echo "$s"
}

# Verify required tools are available
check_commands() {
  local -a cmds=(basename file stat date sed base64 readlink numfmt xml_escape)
  for cmd in "${cmds[@]}"; do
    command -v "$cmd" &>/dev/null || type "$cmd" &>/dev/null || { stderr "Required command not found: $cmd"; return 1; }
  done
  return 0
}

# Convert files to XML format
# Args: $1+ - Input files to process
files_to_xml() {
  (($# < 1)) && { stderr "$FUNCNAME: No input files"; return 1; }
  check_commands || { stderr "$FUNCNAME: Missing required commands"; return 1; }

  local file fqfn name type encoding modified content escaped_file escaped_name
  local -i size total_files=$# current_file=0

  echo "<?xml version=\"$XML_VERSION\" encoding=\"$XML_ENCODING\"?>"
  echo '<Files>'

  for file in "$@"; do
    fqfn=$(readlink -m "$file") || { stderr "$FUNCNAME: Failed to resolve path for '$file'"; continue; }
    [[ -f "$fqfn" && -r "$fqfn" ]] || { stderr "$FUNCNAME: File '$fqfn' not found or not readable"; continue; }

    current_file=$((current_file+1))
    ((VERBOSE)) && { stderr "Processing file $current_file of $total_files: $fqfn"; }

    name=$(basename "$fqfn") || { stderr "$FUNCNAME: Failed to get basename for '$fqfn'"; continue; }
    type=$(file --mime-type -b "$fqfn") || { stderr "$FUNCNAME: Failed to get type for '$fqfn'"; continue; }
    encoding=$(file --mime-encoding -b "$fqfn") || { stderr "$FUNCNAME: Failed to get encoding for '$fqfn'"; continue; }
    size=$(stat -c %s "$fqfn") || { stderr "$FUNCNAME: Failed to get size for '$fqfn'"; continue; }

    # Check file size limit
    if ((size > MAX_FILE_SIZE)); then
      stderr "$FUNCNAME: File '$fqfn' too large ($(numfmt --to=iec-i --suffix=B $size)), skipping"
      continue
    fi

    modified=$(date -d @"$(stat -c %Y "$fqfn")" +"%Y-%m-%dT%H:%M:%S") || { stderr "$FUNCNAME: Failed to get modified time for '$fqfn'"; continue; }
    escaped_file=$(xml_escape "$fqfn")
    escaped_name=$(xml_escape "$name")

    ((VERBOSE)) && { stderr "$FUNCNAME: File details: Name='$name', Type='$type', Encoding='$encoding', Size='$size'"; }

    echo "  <file>"
    echo "    <fqfn>$escaped_file</fqfn>"
    echo "    <n>$escaped_name</n>"
    echo "    <type>$type</type>"
    echo "    <size>$size</size>"
    echo "    <modified>$modified</modified>"

    if [[ "$encoding" == binary ]]; then
      # Binary: base64 encode
      ((VERBOSE)) && { stderr "$FUNCNAME: Handling as binary file"; }
      content=$(base64 -w 0 "$fqfn") || {
        stderr "$FUNCNAME: Failed to base64 encode '$fqfn'"
        echo "    <content encoding=\"base64\" error=\"failed_to_encode\"/>"
        echo "  </file>"
        continue
      }
      echo "    <content encoding=\"base64\">$content</content>"
    else
      # Text: embed in CDATA, escaping "]]>"
      ((VERBOSE)) && { stderr "$FUNCNAME: Handling as text file"; }
      content=$(sed 's/]]>/]]]]><![CDATA[>/g' "$fqfn") || {
        stderr "$FUNCNAME: Failed to process content for '$fqfn'"
        echo "    <content error=\"failed_to_process_cdata\"/>"
        echo "  </file>"
        continue
      }
      echo "    <content><![CDATA[$content]]></content>"
    fi
    echo "  </file>"
  done

  echo '</Files>'
}

# Check if git command is available
# Returns: 0=available, 1=not available
check_git_available() {
  command -v git &>/dev/null
  return $?
}

# Process files from git repositories
# Args: $1+ - Git directories to scan
# Returns: File list via stdout, one file per line, properly quoted
get_git_dirs() {
  local gitdir olddir file
  local -a allFiles=() afiles=()

  # Verify git command is available
  if ! check_git_available; then
    stderr "Required command 'git' not found. Cannot process git repositories."
    return 1
  fi

  for gitdir in "$@"; do
    [[ -z $gitdir ]] && gitdir='.'
    [[ -d "$gitdir"/.git ]] || { stderr "No '$gitdir/.git' directory"; exit 2; }

    olddir="$PWD"
    cd "$gitdir" || { stderr ".git directory '$gitdir' not found"; exit 2; }

    readarray -t allFiles < <(git ls-files)
    for file in "${allFiles[@]}"; do
      for pat in "${IGNORE[@]}"; do
        [[ $file == $pat ]] && continue 2
      done
      # Print each file on its own line, properly quoted for later parsing
      printf "%q\n" "$PWD/$file"
    done
    cd "$olddir"
  done

  return 0
}

# Error reporting function
stderr() {
  >&2 echo -e "files2xml: $1"
}

# Error trap handlers
trap 'echo "files2xml: Error at line $LINENO: Command \"$BASH_COMMAND\" failed with status $?" >&2' ERR
trap 'echo "" >&2' EXIT

# Execute script if run directly
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  # Display usage information
  usage() {
    cat <<EOF
files2xml - Convert files to XML with metadata and content

Usage: ${0##*/} [OPTIONS] [FILE ...]

Arguments:
  FILE                One or more files to include in the XML (optional if --gitdir is used)

Options:
  -m, --max-file-size SIZE  Set maximum file size (default: 1GB)
  -g, --gitdir DIR          Include files from git repository (can be used multiple times)
  -i, --ignore PATTERN      Add glob pattern to ignore list (can be used multiple times)
                            Default patterns: '*.mp*' '~*' '*~' '*.bak' '*.log' '*.old' '*LI*'
                            Use -i with no argument to clear the default patterns
  -v, --verbose             Increase verbosity
  -q, --quiet               Suppress all messages
  -V, --version             Show version information
  -h, --help                Show this help message

Examples:
  # Basic usage
  ${0##*/} file1.txt file2.pdf >files.xml

  # Include git repository files (can be used with explicit files)
  ${0##*/} --gitdir /path/to/repo1 --gitdir /path/to/repo2 additional_file.txt >combined.xml

  # Ignore specific file patterns (adds to default patterns)
  ${0##*/} --ignore "*.tmp" --ignore "*.cache" dir/*.py >files.xml

  # Clear default ignore patterns and set custom ones
  ${0##*/} --ignore "" --ignore "*.tmp" --gitdir /path/to/repo >files.xml

  # Process with XML tools
  ${0##*/} *.sh | xmlstarlet sel -t -v "//file[type='text/x-shellscript']/n"

Features:
  - Text files stored in CDATA sections
  - Binary files base64-encoded
  - XML-escaped paths and names
  - Automatic binary vs. text detection
  - Git repository integration (additive with regular files)
  - Custom file ignore patterns
EOF
    exit "${1:-0}"
  }

  # Main script entry point
  main() {
    local VERSION="1.2.0"
    local PRG="${0##*/}"

    # Parse options
    local -a aFiles=() gitDirs=()
    local options
    options=$(getopt -o m:g:i:vqVh --long max-file-size:,gitdir:,ignore:,verbose,quiet,version,help --name "$PRG" -- "$@")
    if [[ $? -ne 0 ]]; then
        stderr "Error parsing options."
        usage 1
    fi
    eval set -- "$options"

    # Default max file size
    local current_max_file_size="1G"

    # Process options
    while true; do
      case "$1" in
        -m|--max-file-size)
          shift
          current_max_file_size="${1:-$MAX_FILE_SIZE}"
          shift
          ;;
        -g|--gitdir)
          shift
          gitDirs+=( "$(readlink -en -- "$1")" )
          shift
          ;;
        -i|--ignore)
          shift
          if [[ -z "${1:-}" ]]; then
            IGNORE=() # Reset ignore patterns
          else
            IGNORE+=( "$1" ) # Add pattern
          fi
          shift
          ;;
        -v|--verbose) VERBOSE=$((VERBOSE + 1)); shift ;;
        -q|--quiet) VERBOSE=0; shift ;;
        -V|--version) echo "$PRG v${VERSION}"; exit 0 ;;
        -h|--help) usage 0 ;;
        --) shift; break ;;
        *) stderr "Internal error parsing options!"; exit 1 ;;
      esac
    done

    # Convert human-readable size to bytes
    MAX_FILE_SIZE=$(numfmt --from=si --to=none "$current_max_file_size" 2>/dev/null) || {
      stderr "Invalid --max-file-size format '$current_max_file_size'. Use digits with K, M, G suffix."
      exit 1
    }

    # Collect files
    aFiles+=("$@")
    ((VERBOSE)) && { >&2 declare -p aFiles; }

    # Add files from git repositories
    if ((${#gitDirs[@]})); then
      # Create a temporary file for get_git_dirs output to capture exit status
      local git_files_tmp
      git_files_tmp=$(mktemp) || { stderr "Failed to create temporary file"; exit 1; }

      # Run get_git_dirs and capture its exit status
      get_git_dirs "${gitDirs[@]}" > "$git_files_tmp"
      local git_status=$?

      # Only process if get_git_dirs succeeded
      if [[ $git_status -eq 0 ]]; then
        # Use readarray to handle filenames with spaces properly
        while IFS= read -r gitfile; do
          # Skip empty lines
          [[ -z "$gitfile" ]] && continue
          # Evaluate the printf %q quoted format
          eval "aFiles+=( $gitfile )"
        done < "$git_files_tmp"
      else
        stderr "Failed to process git repositories (error $git_status)"
        [[ ${#aFiles[@]} -eq 0 ]] && exit 1
      fi

      # Clean up temporary file
      rm -f "$git_files_tmp"
    fi
    ((VERBOSE)) && { >&2 declare -p gitDirs; }

    # Validate args
    ((${#aFiles[@]})) || { stderr "No input files specified."; usage 1; }
    ((VERBOSE)) && { >&2 declare -p aFiles MAX_FILE_SIZE; }

    local -Ai seen=()
    local -a result=()
    local -- f
    for f in "${aFiles[@]}"; do
      f="$(readlink -fn -- "$f")"
      [[ -v seen["${f//[\/\.\-]/}"] ]] && continue
      # First time seeing this element
      result+=("$f")
      seen["${f//[\/\.\-]/}"]=1
    done
    local -a aFiles=("${result[@]}")

    # Process files
    files_to_xml "${aFiles[@]}"

    # Summary
    ((VERBOSE)) && { stderr "Finished processing ${#aFiles[@]} potential file(s)."; } || true
  }

  # Run main
  main "$@"
fi

#fin
